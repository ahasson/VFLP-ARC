################
# ChemAxon Components
import subprocess
import re
import time
import os
import logging

from run.obabel import (
    write_file_single,
    debug_save_output,
    file_is_empty,
    nonzero_pdb_coordinates,
    generate_remarks,
)


def run_chemaxon_general(
    chemaxon_args, nailgun_port, nailgun_host, must_have_output, timeout=30
):

    chemaxon_args_x = []
    for arg in chemaxon_args:
        if arg != "":
            chemaxon_args_x.append(arg)

    cmd = [
        "ng",
        "--nailgun-server",
        nailgun_host,
        "--nailgun-port",
        nailgun_port,
        *chemaxon_args_x,
    ]

    try:
        ret = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
    except subprocess.TimeoutExpired as err:
        raise RuntimeError(f"chemaxon timed out") from err

    if ret.returncode != 0:
        logging.error(
            f"Chemaxon Return code is {ret.returncode}, stdout:{ret.stdout}, stderr:{ret.stderr}"
        )
        raise RuntimeError(
            f"Chemaxon Return code is {ret.returncode}, stdout:{ret.stdout}, stderr:{ret.stderr}"
        )
    else:
        output_lines = ret.stdout.splitlines()

        if must_have_output and len(output_lines) == 0:
            raise RuntimeError("No output found for chemaxon and is required")
        else:
            for line in ret.stdout.splitlines() + ret.stderr.splitlines():
                if re.search(r"refused", line):
                    raise RuntimeError("The Nailgun server seems to have terminated")
                elif re.search(r"failed|timelimit|error|no such file|not found", line):
                    logging.error(
                        f"cx: An error flag was detected in the log file ({line})"
                    )
                    raise RuntimeError(
                        f"An error flag was detected in the log file ({line})"
                    )

    return {"stdout": ret.stdout, "stderr": ret.stderr}


def run_chemaxon_calculator(cxargs, local_file, nailgun_port, nailgun_host, timeout=30):
    local_args = ["chemaxon.marvin.Calculator", *cxargs, local_file]

    return run_chemaxon_general(
        local_args, nailgun_port, nailgun_host, must_have_output=1, timeout=timeout
    )


# Step 1: Desalt (not performed by ChemAxon)
# Step 2: Neutralization by Standardizer


def run_chemaxon_neutralization_standardizer(ctx, ligand):

    step_timer_start = time.perf_counter()

    # Place smi string into a file that can be read
    local_file = ctx["intermediate_dir"] / "desalted.smi"
    write_file_single(local_file, ligand["smi_desalted"])

    local_args = [
        "chemaxon.standardizer.StandardizerCLI",
        local_file,
        "-c",
        "neutralize",
    ]

    ret = run_chemaxon_general(
        local_args,
        ctx["config"]["nailgun_port"],
        ctx["config"]["nailgun_host"],
        must_have_output=1,
        timeout=ctx["config"]["chemaxon_neutralization_timeout"],
    )

    debug_save_output(
        stdout=ret["stdout"],
        stderr=ret["stderr"],
        ctx=ctx,
        file="chemaxon_neutralization",
    )

    output_lines = ret["stdout"].splitlines()
    ligand["smi_neutralized"] = output_lines[-1]
    ligand["neutralization_success"] = 1
    ligand["remarks"][
        "neutralization"
    ] = f"The compound was neutralized by Standardizer version {ctx['versions']['standardizer']} of ChemAxons JChem Suite."
    ligand["neutralization_type"] = "genuine"

    ligand["timers"].append(
        ["chemaxon_neutralization", time.perf_counter() - step_timer_start]
    )


# Step 3a: Stereoisomer Generation by ChemAxon


def run_chemaxon_stereoisomer_generation(ctx, ligand):
    step_timer_start = time.perf_counter()

    # Place smi string into a file that can be read
    local_file = ctx["intermediate_dir"] / "neutralized.smi"
    write_file_single(local_file, ligand["smi_neutralized"])

    local_args = [
        "chemaxon.marvin.Calculator",
        "stereoisomers",
        *(ctx["config"]["cxcalc_stereoisomer_generation_options"].split()),
        local_file,
    ]

    ligand["stereoisomer_smiles"] = []

    ret = run_chemaxon_general(
        local_args,
        ctx["config"]["nailgun_port"],
        ctx["config"]["nailgun_host"],
        must_have_output=1,
        timeout=ctx["config"]["cxcalc_stereoisomer_timeout"],
    )

    debug_save_output(
        stdout=ret["stdout"],
        stderr=ret["stderr"],
        ctx=ctx,
        file="chemaxon_stereoisomer",
    )

    lines = ret["stdout"].splitlines()
    if len(lines) >= 1:
        for line in lines:
            ligand["stereoisomer_smiles"].append(line)

        ligand["remarks"][
            "stereoisomer"
        ] = f"The stereoisomers were generated by cxcalc version {ctx['versions']['cxcalc']} of ChemAxons JChem Suite."
        ligand["timers"].append(
            ["chemaxon_stereoisomer", time.perf_counter() - step_timer_start]
        )
        return
    else:
        raise RuntimeError("No output for stereoisomer state generation")

    raise RuntimeError("Stereoisomer generation failed")


# Step 3b: Tautomerization by ChemAxon


def run_chemaxon_tautomer_generation(ctx, stereoisomer):
    step_timer_start = time.perf_counter()

    # Place smi string into a file that can be read
    local_file = ctx["intermediate_dir"] / "stereoisomer.smi"
    write_file_single(local_file, stereoisomer["smi"])

    local_args = [
        "chemaxon.marvin.Calculator",
        "tautomers",
        *(ctx["config"]["cxcalc_tautomerization_options"].split()),
        local_file,
    ]

    stereoisomer["tautomer_smiles"] = []

    ret = run_chemaxon_general(
        local_args,
        ctx["config"]["nailgun_port"],
        ctx["config"]["nailgun_host"],
        must_have_output=1,
        timeout=ctx["config"]["cxcalc_tautomerization_timeout"],
    )

    debug_save_output(
        stdout=ret["stdout"],
        stderr=ret["stderr"],
        ctx=ctx,
        file="chemaxon_tautomerization",
    )

    lines = ret["stdout"].splitlines()

    if len(lines) >= 1:
        tautomer_smiles_strings = lines[-1].split()
        if len(tautomer_smiles_strings) > 1:
            stereoisomer["tautomer_smiles"] = tautomer_smiles_strings[1].split(".")
            stereoisomer["remarks"][
                "tautomerization"
            ] = f"The tautomeric state was generated by cxcalc version {ctx['versions']['cxcalc']} of ChemAxons JChem Suite."
            stereoisomer["timers"].append(
                ["chemaxon_tautomerization", time.perf_counter() - step_timer_start]
            )
            return
        else:
            stereoisomer["timers"].append(
                ["chemaxon_tautomerization", time.perf_counter() - step_timer_start]
            )
            raise RuntimeError(
                f"Not able to split last line on spaces line={'|'.join(lines)})"
            )
    else:
        stereoisomer["timers"].append(
            ["chemaxon_tautomerization", time.perf_counter() - step_timer_start]
        )
        raise RuntimeError("No output for tautomer state generation")

    stereoisomer["timers"].append(
        ["chemaxon_tautomerization", time.perf_counter() - step_timer_start]
    )
    raise RuntimeError("Tautomer state generation failed")


# Step 4: Protonation by ChemAxon


def cxcalc_protonate(ctx, tautomer):

    logging.debug(f"Running protonation with cxcalc for {tautomer['key']}")

    # Place smi string into a file that can be read

    local_file = tautomer["intermediate_dir"] / f"before_protonate.smi"
    write_file_single(local_file, tautomer["smi"])

    ret = run_chemaxon_calculator(
        ["majorms", "-H", str(ctx["config"]["protonation_pH_value"])],
        local_file,
        ctx["config"]["nailgun_port"],
        ctx["config"]["nailgun_host"],
        timeout=ctx["config"]["cxcalc_protonation_timeout"],
    )

    debug_save_output(
        stdout=ret["stdout"],
        stderr=ret["stderr"],
        ctx=ctx,
        tautomer=tautomer,
        file="chemaxon_protonate",
    )

    logging.debug(f"succesful protonation with cxcalc for {tautomer['key']}")

    output_lines = ret["stdout"].splitlines()
    if len(output_lines) > 1:
        line = output_lines[-1]
        line_split = line.split("\t", 2)
        if len(line_split) > 1:
            tautomer["smi_protomer"] = line_split[1]

            # Chemaxon can sometimes provide a second string. Just use the
            # first one
            # parts = line_split[1].split()
            # if(len(parts) > 1):
            # 	tautomer['smi_protomer'] = parts[0]
            # 	print (f"smi_protomer just updated to {parts[0]}, was {line_split[1]}")

            tautomer["remarks"][
                "protonation"
            ] = f"Protonation state was generated at pH {ctx['config']['protonation_pH_value']} by cxcalc version {ctx['versions']['cxcalc']} of ChemAxons JChem Suite."
            logging.debug(f"smi_protomer is {tautomer['smi_protomer']}")
            return

    raise RuntimeError("Protonation state generation failed")


# Step 5: Assign Tranche

# Single function used to lookup multiple attributes for tranche
# assignment
#
# Get the last line of output, the value if interest is after the tab character


def run_cxcalc_attributes(
    tautomer,
    local_file,
    nailgun_port,
    nailgun_host,
    attribute_list,
    attributes,
    use_single=0,
):

    step_timer_start = time.perf_counter()

    if use_single == 1:
        attrs = {}

        cxcalc_attrs = []
        for attr in attribute_list:
            if attr in attributes and attributes[attr]["prog"] == "cxcalc":
                cxcalc_attrs.append(attributes[attr]["prog_name"])

        local_args = ["vf.CxCalcAttr", local_file, *cxcalc_attrs]

        ret = run_chemaxon_general(
            local_args, nailgun_port, nailgun_host, must_have_output=1
        )

        # Check output
        output_lines = ret["stdout"].splitlines()
        if len(output_lines) > 0:
            for line in output_lines:
                attr = line.split(",", 2)
                if len(attr) == 2:
                    (attr_key, attr_value) = line.split(",", 2)
                    attrs[attr_key] = attr_value
                else:
                    raise RuntimeError("Unable to parse output of CxCalcAttr")
        else:
            raise RuntimeError("Unable to parse output of CxCalcAttr")

        for attr in attribute_list:
            if attr in attributes and attributes[attr]["prog"] == "cxcalc":
                attributes[attr]["val"] = attrs[attributes[attr]["prog_name"]]
    else:

        for attr in attribute_list:
            if attr in attributes and attributes[attr]["prog"] == "cxcalc":
                attributes[attr]["val"] = cxcalc_attribute(
                    tautomer,
                    local_file,
                    [attributes[attr]["prog_name"]],
                    nailgun_port,
                    nailgun_host,
                )

    tautomer["timers"].append(
        [f"chemaxon_attr", time.perf_counter() - step_timer_start]
    )
    return attributes


def cxcalc_attribute(tautomer, local_file, arguments, nailgun_port, nailgun_host):

    step_timer_start = time.perf_counter()
    ret = run_chemaxon_calculator(arguments, local_file, nailgun_port, nailgun_host)

    output_lines = ret["stdout"].splitlines()
    if len(output_lines) > 1:
        line = output_lines[-1]
        line_split = line.split("\t", 2)
        if len(line_split) > 1:
            tautomer["timers"].append(
                [
                    f"chemaxon_attr_{arguments[0]}",
                    time.perf_counter() - step_timer_start,
                ]
            )
            return line_split[1]

    tautomer["timers"].append(
        [f"chemaxon_attr_{arguments[0]}", time.perf_counter() - step_timer_start]
    )
    raise RuntimeError("Unable to parse output of run_chemaxon_calculator")


#
# Step 6: 3D conformation generation


def chemaxon_conformation(ctx, tautomer, output_file):

    logging.debug(f"Running chemaxon_conformation on smi:'{tautomer['smi_protomer']}")

    output_file_tmp = f"{output_file}.tmp"
    input_file = f"{ctx['temp_dir'].name}/molconvert.conf.{tautomer['key']}_input.smi"

    write_file_single(input_file, tautomer["smi_protomer"])
    molconvert_generate_conformation(ctx, tautomer, input_file, output_file_tmp)

    if not os.path.isfile(output_file_tmp):
        logging.debug("No pdb file generated in conformation")
        raise RuntimeError("No pdbfile generated")
    if file_is_empty(output_file_tmp):
        logging.debug(
            f"chemaxon outputfile is empty. smi: |{tautomer['smi_protomer']}|"
        )
        raise RuntimeError(
            f"chemaxon outputfile is empty. smi: |{tautomer['smi_protomer']}|"
        )

    if not nonzero_pdb_coordinates(output_file_tmp):
        logging.debug(
            f"The output PDB file exists but does not contain valid coordinates."
        )
        raise RuntimeError(
            "The output PDB file exists but does not contain valid coordinates."
        )

    # FIXME -- do we want this? This will grab only the first part of an SMI string and will
    # ignore extended attributes
    first_smile_component = tautomer["smi_protomer"].split()[0]

    tautomer["remarks"][
        "conformation"
    ] = f"Generation of the 3D conformation was carried out by molconvert version {ctx['versions']['molconvert']}"
    tautomer["remarks"]["targetformat"] = "Format generated as part of 3D conformation"
    # tautomer['remarks']['smiles'] = f"SMILES: {first_smile_component}"

    # Modifying the header of the pdb file and correction of the charges in the pdb file in
    # order to be conform with the official specifications (otherwise problems with obabel)

    local_remarks = tautomer["remarks"].copy()
    local_remarks.pop("compound")
    remark_string = generate_remarks(local_remarks) + "\n"

    line_count = 0
    with open(output_file, "w") as write_file:
        write_file.write(f"COMPND    Compound: {tautomer['key']}\n")
        write_file.write(remark_string)
        with open(output_file_tmp, "r") as read_file:
            for line in read_file:
                line_count += 1
                if re.search(r"TITLE|SOURCE|KEYWDS|EXPDTA|COMPND|HEADER|AUTHOR", line):
                    continue
                line = re.sub(r"REVDAT.*$", "\n", line)
                line = re.sub(r"NONE", "", line)
                line = re.sub(r" UN[LK] ", " LIG ", line)
                line = re.sub(r"\+0", "", line)
                line = re.sub(r"([+-])([0-9])$", r"\2\1", line)
                if re.search(r"^\s*$", line):
                    continue
                write_file.write(line)

    logging.debug("success for chemaxon_conformation")


def molconvert_generate_conformation(ctx, tautomer, input_file, output_file):
    logging.debug(f"Running conformation with molconvert for {tautomer['key']}")
    run_molconvert(
        [*(str(ctx["config"]["molconvert_3D_options"]).split())],
        input_file,
        output_file,
        ctx["config"]["nailgun_port"],
        ctx["config"]["nailgun_host"],
        timeout=ctx["config"]["molconvert_conformation_timeout"],
    )


def run_molconvert(
    molconvert_3D_options,
    input_file,
    output_file,
    nailgun_port,
    nailgun_host,
    timeout=30,
):
    local_args = [
        "chemaxon.formats.MolConverter",
        "pdb:+H",
        *molconvert_3D_options,
        input_file,
        "-o",
        output_file,
    ]
    run_chemaxon_general(
        local_args, nailgun_port, nailgun_host, must_have_output=0, timeout=timeout
    )
